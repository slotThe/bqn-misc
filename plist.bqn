# Parsing nested lists of the form
#
#     [1, [[2, 5], 3, [4]], 6]
#
# in both an array, and a recursive descent-like style.
#
# For now, mostly following
#
#     https://saltysylvi.github.io/blog/parsing-nested-lists-in-bqn.html

### Recursive descent approach

RDTok â† {
  ds â† Â»âŠ¸<ğ•©âˆŠ'0'+â†•10         # Digits
  ts â† ğ•©âˆŠ"[]"               # Other tokens
  rs â† 1-Ëœ(Â¬ğ•©âˆŠ", ")Ã—+`tsâˆ¨ds # Sum scan (for group) and eliminate commas and whitespace
  rsâŠ”ğ•©
}
RDNum â† { âŸ¨â€¢ParseFloat âŠ‘ğ•©, 1â†“ğ•©âŸ© }
RDLst â† {
  "]"â‰¡âŠ‘ğ•©? âŸ¨ğ•¨, 1â†“ğ•©âŸ©;
  vâ€¿rs â† RDVal ğ•©
  (ğ•¨âˆ¾<v) RDLst rs
}
RDVal â† { "["â‰¡âŠ‘ğ•©? âŸ¨âŸ© RDLst 1â†“ğ•©; RDNum ğ•© }
RDParse â† âŠ‘âˆ˜RDValâˆ˜RDTok

### Array approach

ATok â† RDTok
OB â† "["âŠ¸â‰¡Â¨     # Opening brackets
CB â† "]"âŠ¸â‰¡Â¨     # Closing brackets

AParse â† {
  d       â† +`âˆ˜(OB-CB) tâ†ATokğ•©    # Depth reading
  Split   â† { 1â†“ 1âŠ¸â†“Â¨(+`OBğ•©)âŠ”ğ•© }
  Replace â† { ğ•¨âŒ¾((CBğ•©)âŠ¸/)ğ•© }
  {âŸ¨âŸ©â‰¡ğ•©?âŸ¨âŸ©;â€¢ParseFloatğ•©}âš‡1 âŠ‘{(Split ğ•©) Replace ğ•¨}Â´ dâŠ”t
}

# Going through this line by line:
#
#     t â† ATok"[1,[[2,[],5],3,[4]],6]"
# âŸ¨ "[" "1" "[" "[" "2" "[" "]" "5" "]" "3" "[" "4" "]" "]" "6" "]" âŸ©
#     o â† "["âŠ¸â‰¡Â¨t
# âŸ¨ 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 0 âŸ©
#     c â† "]"âŠ¸â‰¡Â¨t
# âŸ¨ 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0 1 âŸ©
#     d â† +`o-c
# âŸ¨ 1 1 2 3 3 4 3 3 2 2 3 3 2 1 1 0 âŸ©
#     (â‹d)âŠt
# âŸ¨ "]" "[" "1" "]" "6" "[" "]" "3" "]" "[" "2" "]" "5" "[" "4" "[" âŸ©
#
# Closing brackets indicate further nesting and opening brackets signify the
# start of a new sublist. Using these rules, this is just a bfs representation
# of the treeâ€”drawing a tree on a piece of paper very much helps. A different
# Unicode representation, using â†“ for a closing bracket and âˆ˜ for an opening
# one, yields
#
#     â†“
#     âˆ˜ 1 â†“ 6
#         âˆ˜ â†“   3    â†“
#           âˆ˜ 2 â†“ 5  âˆ˜ 4
#               âˆ˜
#
# We can now partition the tokenised input according to the depth, carving out
# exactly the levels depicted above:
#
#     d âŠ” t
# âŸ¨ âŸ¨ "]" âŸ© âŸ¨ "[" "1" "]" "6" âŸ© âŸ¨ "[" "]" "3" "]" âŸ© âŸ¨ "[" "2" "]" "5" "[" "4" âŸ© âŸ¨ "[" âŸ© âŸ©
#
# Splitting is standard:
#
#     { 1â†“1âŠ¸â†“Â¨(+`"["âŠ¸â‰¡Â¨ğ•©)âŠ”ğ•© } "["â€¿"3"â€¿"4"â€¿"]"â€¿"["â€¿"9"â€¿"10"
# âŸ¨ âŸ¨ "3" "4" "]" âŸ© âŸ¨ "9" "10" âŸ© âŸ©
#
# And Replace should be self-explanatory as well. When folding, we split the
# accumulator on the first opening bracket, and then plug whatever we find
# into the closing bracket of the given element.
#
#     {(Split ğ•©) Replace ğ•¨}Â´ dâŠ”t
# â”Œâ”€
# Â· â”Œâ”€
# Â· "1" â”Œâ”€                             "6"
#      Â· âŸ¨ "2" âŸ¨âŸ© "5" âŸ© "3" âŸ¨ "4" âŸ©
#                                   â”˜
#                                         â”˜
#                                           â”˜
#
# The rest is just boilerplate so that a nicely formatted list falls out.

### Performance

# Some AoC day using exactly this format.
SplitF â‡ { ((Â¯1+âŠ¢Ã—Â·+`Â»âŠ¸<)Â¬ğ•¨âŠ¸â‰¡Â¨ğ•©)âŠ”ğ•© }
input â† ']'âˆ¾Ëœ '['âˆ¾ Â¯1â†“ âˆ¾ âˆ¾âŸœ","Â¨ âˆ¾âŸ¨âŸ©SplitF â€¢FLines"/home/slot/repos/advent/aoc2022/inputs/day13.txt"

(RDParse input) â‰¡ AParse input # â‡’ 1
100 RDParseâ€¢_timed input       # â‡’ 0.00311369804
100 AParse â€¢_timed input       # â‡’ 0.00244539886
