# Parsing nested lists of the form
#
#     [1, [[2, 5], 3, [4]], 6]
#
# in both an array, and a recursive descent-like style.
#
# For now, mostly following
#
#     https://saltysylvi.github.io/blog/parsing-nested-lists-in-bqn.html

### Recursive descent approach

RDTok â† {
  ds â† Â»âŠ¸<ğ•©âˆŠ'0'+â†•10         # Digits
  ts â† ğ•©âˆŠ"[]"               # Other tokens
  rs â† 1-Ëœ(Â¬ğ•©âˆŠ", ")Ã—+`tsâˆ¨ds # Sum scan (for group) and eliminate commas and whitespace
  rsâŠ”ğ•©
}
RDNum â† { âŸ¨â€¢ParseFloat âŠ‘ğ•©, 1â†“ğ•©âŸ© }
RDLst â† {
  "]"â‰¡âŠ‘ğ•©? âŸ¨ğ•¨, 1â†“ğ•©âŸ©;
  vâ€¿rs â† RDVal ğ•©
  (ğ•¨âˆ¾<v) RDLst rs
}
RDVal â† { "["â‰¡âŠ‘ğ•©? âŸ¨âŸ© RDLst 1â†“ğ•©; RDNum ğ•© }
RDParse â† âŠ‘âˆ˜RDValâˆ˜RDTok

### Array approach, still nested

ATok â† RDTok
OB â† "["âŠ¸â‰¡Â¨     # Opening brackets
CB â† "]"âŠ¸â‰¡Â¨     # Closing brackets

AParse â† {
  d       â† +`âˆ˜(OB-CB) tâ†ATokğ•©    # Depth reading
  Split   â† { 1â†“ 1âŠ¸â†“Â¨(+`OBğ•©)âŠ”ğ•© }
  Replace â† { ğ•¨âŒ¾((CBğ•©)âŠ¸/)ğ•© }
  {âŸ¨âŸ©â‰¡ğ•©?âŸ¨âŸ©;â€¢ParseFloatğ•©}âš‡1 âŠ‘{(Split ğ•©) Replace ğ•¨}Â´ dâŠ”t
}

# Going through this line by line:
#
#     t â† ATok"[1,[[2,[],5],3,[4]],6]"
# âŸ¨ "[" "1" "[" "[" "2" "[" "]" "5" "]" "3" "[" "4" "]" "]" "6" "]" âŸ©
#     o â† "["âŠ¸â‰¡Â¨t
# âŸ¨ 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 0 âŸ©
#     c â† "]"âŠ¸â‰¡Â¨t
# âŸ¨ 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0 1 âŸ©
#     d â† +`o-c
# âŸ¨ 1 1 2 3 3 4 3 3 2 2 3 3 2 1 1 0 âŸ©
#     (â‹d)âŠt
# âŸ¨ "]" "[" "1" "]" "6" "[" "]" "3" "]" "[" "2" "]" "5" "[" "4" "[" âŸ©
#
# Closing brackets indicate further nesting and opening brackets signify the
# start of a new sublist. Using these rules, this is just a bfs representation
# of the treeâ€”drawing a tree on a piece of paper very much helps. A different
# Unicode representation, using â†“ for a closing bracket and âˆ˜ for an opening
# one, yields
#
#     â†“
#     âˆ˜ 1 â†“ 6
#         âˆ˜ â†“   3    â†“
#           âˆ˜ 2 â†“ 5  âˆ˜ 4
#               âˆ˜
#
# We can now partition the tokenised input according to the depth, carving out
# exactly the levels depicted above:
#
#     d âŠ” t
# âŸ¨ âŸ¨ "]" âŸ© âŸ¨ "[" "1" "]" "6" âŸ© âŸ¨ "[" "]" "3" "]" âŸ© âŸ¨ "[" "2" "]" "5" "[" "4" âŸ© âŸ¨ "[" âŸ© âŸ©
#
# Splitting is standard:
#
#     { 1â†“1âŠ¸â†“Â¨(+`"["âŠ¸â‰¡Â¨ğ•©)âŠ”ğ•© } "["â€¿"3"â€¿"4"â€¿"]"â€¿"["â€¿"9"â€¿"10"
# âŸ¨ âŸ¨ "3" "4" "]" âŸ© âŸ¨ "9" "10" âŸ© âŸ©
#
# And Replace should be self-explanatory as well. When folding, we split the
# accumulator on the first opening bracket, and then plug whatever we find
# into the closing bracket of the given element.
#
#     {(Split ğ•©) Replace ğ•¨}Â´ dâŠ”t
# â”Œâ”€
# Â· â”Œâ”€
# Â· "1" â”Œâ”€                             "6"
#      Â· âŸ¨ "2" âŸ¨âŸ© "5" âŸ© "3" âŸ¨ "4" âŸ©
#                                   â”˜
#                                         â”˜
#                                           â”˜
#
# The rest is just boilerplate so that a nicely formatted list falls out.

### Flat array approach

FATok â† {
  ns â† Â»âŠ¸< nâ†ğ•©âˆŠ'0'+â†•10
  ds â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`ns)âŠ”ğ•©  # All digits
  f  â† nsâˆ¨ğ•©âˆŠ"[]"                  # First occurrences
  âŸ¨ 'Â·'Â¨âŒ¾((f/n)âŠ¸/)(f/ğ•©), ds âŸ©
}

#     a â† "[1,2,[3,4,[5,6]],7,8,[9,10]]"
# "[1,2,[3,4,[5,6]],7,8,[9,10]]"
#     ns â† Â»âŠ¸< nâ†aâˆŠ'0'+â†•10        # ns is the first occurrence of a number (so "10" gets 1â€¿0)
# âŸ¨ 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 1 0 0 0 âŸ©
#     n                           # n is all numbers (so "10" gets 1â€¿1)
# âŸ¨ 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 1 1 0 0 âŸ©
#     ds â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`ns)âŠ”a # Number tokens in a separate list
# âŸ¨ 1 2 3 4 5 6 7 8 9 10 âŸ©
#     f  â† nsâˆ¨aâˆŠ"[]"                 # First occurrences of everything
# âŸ¨ 1 1 0 1 0 1 1 0 1 0 1 1 0 1 1 1 0 1 0 1 0 1 1 0 1 0 1 1 âŸ©
#
# At this point we need to work with the shape of the array we are trying to
# build -- that in which everything is represented by one character only.
#
#     f/a                 # Shape of the new array
# "[12[34[56]]78[91]]"
#     f/n                 # What are the number tokens in the new array?
# âŸ¨ 0 1 1 0 1 1 0 1 1 0 0 1 1 0 1 1 0 0 âŸ©
#     'Â·'Â¨âŒ¾((f/n)âŠ¸/)(f/a) # Replace numbers with 'Â·'
# "[Â·Â·[Â·Â·[Â·Â·]]Â·Â·[Â·Â·]]"

FAParse â† {
  tokâ€¿num â† FATok ğ•©
  o â† '['=tok
  c â† ']'=tok
  g â† â‹+`(o-c)          # Grading by depth
  f â† tokâˆŠ"Â·]"          # Numbers and nesting
  k â† â‹â‹ (f/'Â·'=tok) + 2Ã—f/c
  l â† (â‹g)âŠ +`'['=gâŠtok # Sublist index
  i â† k âŠ (â†•nv) âˆ¾ (nvâ†â‰ num)+ â‰ âŠ¸- c/Â»l
  val â† num             # Mutation is evil
  {valâˆ¾â†©<ğ•©âŠvalâ‹„@}Â¨ âŒ½((+Â´c)âˆ¾Ëœ1-Ëœf/l)âŠ”i
  Â¯1âŠ‘val
}

# This one is a real doozy. The first few steps are not so complicated:
#
#     tokâ€¿num â† FATok "[1,2,[],[3,4,[5,6]],7,8,[9,10]]"
# âŸ¨ "[Â·Â·[][Â·Â·[Â·Â·]]Â·Â·[Â·Â·]]" âŸ¨ 1 2 3 4 5 6 7 8 9 10 âŸ© âŸ©
#     o â† '['=tok
# âŸ¨ 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 âŸ©
#     c â† ']'=tok
# âŸ¨ 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 1 âŸ©
#     g â† â‹+`(o-c)
# âŸ¨ 19 0 1 2 4 12 13 14 18 3 5 6 7 11 15 16 17 8 9 10 âŸ©
#
# A standard ordering things by depth. We know this. Then we get the numbers
# and additional sublists (nesting) from the original token array.
#
#     tokâ‰ nnâ†tokâˆŠ"Â·]"
# â”Œâ”€
# â•µ '[' 'Â·' 'Â·' '[' ']' '[' 'Â·' 'Â·' '[' 'Â·' 'Â·' ']' ']' 'Â·' 'Â·' '[' 'Â·' 'Â·' ']' ']'
#    0   1   1   0   1   0   1   1   0   1   1   1   1   1   1   0   1   1   1   1
#                                                                                   â”˜
# Now we concentrate on these values and further sublists.
#
#     nn/tok
# "Â·Â·]Â·Â·Â·Â·]]Â·Â·Â·Â·]]"
#     (nn/tok) â‰ (nn/'Â·'=tok) + 2Ã—nn/c
# â”Œâ”€
# â•µ 'Â·' 'Â·' ']' 'Â·' 'Â·' 'Â·' 'Â·' ']' ']' 'Â·' 'Â·' 'Â·' 'Â·' ']' ']'
#    1   1   2   1   1   1   1   2   2   1   1   1   1   2   2
#                                                               â”˜
# We can use the ordinals pattern to see where the individual things would end
# up with were we to sort the list.
#
#     k â† â‹â‹ (nn/'Â·'=tok) + 2Ã—nn/c
# âŸ¨ 0 1 10 2 3 4 5 11 12 6 7 8 9 13 14 âŸ©
#     (nn/tok)â‰k
# â”Œâ”€
# â•µ 'Â·' 'Â·' ']' 'Â·' 'Â·' 'Â·' 'Â·' ']' ']' 'Â·' 'Â·' 'Â·' 'Â·' ']' ']'
#    0   1   10  2   3   4   5   11  12  6   7   8   9   13  14
#                                                                â”˜
# This at least gets us the right indices for all numbers. However, the
# sublists are not quite right, still, but not unexpected -- so far we haven't
# used the opening brackets at all! This is where things get spicy. We first
# want to order the sublists according to their depth.
#
#
#     gâŠtok              # depth ordering again
# "][Â·Â·]]Â·Â·][[Â·Â·][Â·Â·[Â·Â·"
#     +`'['=gâŠtok
# âŸ¨ 0 1 1 1 1 1 1 1 1 2 3 3 3 3 4 4 4 5 5 5 âŸ©
#
# Crucially, however, we don't want this depth index in depth order, but in
# the ordinary order that 'tok' and also 'k' are in. This we can do with the
# observation that we can easily invert permutations with â‹.
#
#     tokâ‰ lâ†(â‹g)âŠ+`'['=gâŠtok
# â”Œâ”€
# â•µ '[' 'Â·' 'Â·' '[' ']' '[' 'Â·' 'Â·' '[' 'Â·' 'Â·' ']' ']' 'Â·' 'Â·' '[' 'Â·' 'Â·' ']' ']'
#    1   1   1   2   1   3   3   3   5   5   5   3   1   1   1   4   4   4   1   0
#                                                                                   â”˜
# With this we can essentially number the sublists of the structure by depth.
#
#     c/Â»l
# âŸ¨ 2 5 3 4 1 âŸ©
#
# Aligning the indices with the sublists yields something like
#
#     [Â·Â·[][Â·Â·[Â·Â·]]Â·Â·[Â·Â·]]
#         2      53     41
#
# This means that, at the end, we shall construct sublist 2 first, then 5,
# then 3, and so on. Since we build the list depth-first, we need to invert
# the current order, and also take into consideration that we have values to
# insert.
#
#     (nvâ†â‰ num)+ â‰ âŠ¸- c/Â»l
# âŸ¨ 13 10 12 11 14 âŸ©
#
# We can finally build the full list of indices, and use the value indices to
# index them.
#
#     (â†•nv) âˆ¾ (nvâ†â‰ num)+ â‰ âŠ¸- c/Â»l
# âŸ¨ 0 1 2 3 4 5 6 7 8 9 13 10 12 11 14 âŸ©
#     i â† kâŠ(â†•nv) âˆ¾ (nvâ†â‰ num)+ â‰ âŠ¸- c/Â»l
# âŸ¨ 0 1 13 2 3 4 5 10 12 6 7 8 9 11 14 âŸ©
#
# Almost done -- all that's left is to build everything up recursively, just
# as we did in the nested array version.
#
#     (+Â´c)âˆ¾Ëœ1-Ëœnn/l
# âŸ¨ 0 0 0 2 2 4 4 2 0 0 0 3 3 0 Â¯1 5 âŸ©
#     âŒ½((+Â´c)âˆ¾Ëœ1-Ëœnn/l)âŠ”i
# âŸ¨ âŸ¨ 4 5 âŸ© âŸ¨ 8 9 âŸ© âŸ¨ 2 3 15 âŸ© âŸ¨âŸ© âŸ¨ 0 1 12 13 6 7 14 âŸ© âŸ©
#
#     val â† num             # Mutation is evil
#     {valâˆ¾â†©<ğ•©âŠvalâ‹„@}Â¨ âŒ½((+Â´c)âˆ¾Ëœ1-Ëœnn/l)âŠ”i
#     Â¯1âŠ‘val
# â”Œâ”€
# Â· 1 2 âŸ¨âŸ© âŸ¨ 3 4 âŸ¨ 5 6 âŸ© âŸ© 7 8 âŸ¨ 9 10 âŸ©
#                                       â”˜
#     a
# "[1,2,[],[3,4,[5,6]],7,8,[9,10]]"

### Performance

# Some AoC day using exactly this format.
SplitF â‡ { ((Â¯1+âŠ¢Ã—Â·+`Â»âŠ¸<)Â¬ğ•¨âŠ¸â‰¡Â¨ğ•©)âŠ”ğ•© }
input â† ']'âˆ¾Ëœ '['âˆ¾ Â¯1â†“ âˆ¾ âˆ¾âŸœ","Â¨ âˆ¾âŸ¨âŸ©SplitF â€¢FLines"/home/slot/repos/advent/aoc2022/inputs/day13.txt"

(RDParse input) â‰¡ AParse input  # â‡’ 1
(FAParse input) â‰¡ AParse input  # â‡’ 1
100 RDParseâ€¢_timed input        # â‡’ 0.00269128438
100 AParse â€¢_timed input        # â‡’ 0.00236296291
100 FAParseâ€¢_timed input        # â‡’ 0.00118868171
