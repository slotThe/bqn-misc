# Parsing nested lists of the form
#
#     [1, [[2, 5], 3, [4]], 6]
#
# in both an array, and a recursive descent-like style.
#
# For now, mostly following
#
#     https://saltysylvi.github.io/blog/parsing-nested-lists-in-bqn.html

### Recursive descent approach

RDTok â† {
  ds â† Â»âŠ¸<ğ•©âˆŠ'0'+â†•10         # Digits
  ts â† ğ•©âˆŠ"[]"               # Other tokens
  rs â† 1-Ëœ(Â¬ğ•©âˆŠ", ")Ã—+`tsâˆ¨ds # Sum scan (for group) and eliminate commas and whitespace
  rsâŠ”ğ•©
}
RDNum â† { âŸ¨â€¢ParseFloat âŠ‘ğ•©, 1â†“ğ•©âŸ© }
RDLst â† {
  "]"â‰¡âŠ‘ğ•©? âŸ¨ğ•¨, 1â†“ğ•©âŸ©;
  vâ€¿rs â† RDVal ğ•©
  (ğ•¨âˆ¾<v) RDLst rs
}
RDVal â† { "["â‰¡âŠ‘ğ•©? âŸ¨âŸ© RDLst 1â†“ğ•©; RDNum ğ•© }
RDParse â† âŠ‘âˆ˜RDValâˆ˜RDTok

### Array approach, still nested

ATok â† RDTok
OB â† "["âŠ¸â‰¡Â¨     # Opening brackets
CB â† "]"âŠ¸â‰¡Â¨     # Closing brackets

AParse â† {
  d       â† +`âˆ˜(OB-CB) tâ†ATokğ•©    # Depth reading
  Split   â† { 1â†“ 1âŠ¸â†“Â¨(+`OBğ•©)âŠ”ğ•© }
  Replace â† { ğ•¨âŒ¾((CBğ•©)âŠ¸/)ğ•© }
  {âŸ¨âŸ©â‰¡ğ•©?âŸ¨âŸ©;â€¢ParseFloatğ•©}âš‡1 âŠ‘{(Split ğ•©) Replace ğ•¨}Â´ dâŠ”t
}

# Going through this line by line:
#
#     t â† ATok"[1,[[2,[],5],3,[4]],6]"
# âŸ¨ "[" "1" "[" "[" "2" "[" "]" "5" "]" "3" "[" "4" "]" "]" "6" "]" âŸ©
#     o â† "["âŠ¸â‰¡Â¨t
# âŸ¨ 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 0 âŸ©
#     c â† "]"âŠ¸â‰¡Â¨t
# âŸ¨ 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0 1 âŸ©
#     d â† +`o-c
# âŸ¨ 1 1 2 3 3 4 3 3 2 2 3 3 2 1 1 0 âŸ©
#     (â‹d)âŠt
# âŸ¨ "]" "[" "1" "]" "6" "[" "]" "3" "]" "[" "2" "]" "5" "[" "4" "[" âŸ©
#
# Closing brackets indicate further nesting and opening brackets signify the
# start of a new sublist. Using these rules, this is just a bfs representation
# of the treeâ€”drawing a tree on a piece of paper very much helps. A different
# Unicode representation, using â†“ for a closing bracket and âˆ˜ for an opening
# one, yields
#
#     â†“
#     âˆ˜ 1 â†“ 6
#         âˆ˜ â†“   3    â†“
#           âˆ˜ 2 â†“ 5  âˆ˜ 4
#               âˆ˜
#
# We can now partition the tokenised input according to the depth, carving out
# exactly the levels depicted above:
#
#     d âŠ” t
# âŸ¨ âŸ¨ "]" âŸ© âŸ¨ "[" "1" "]" "6" âŸ© âŸ¨ "[" "]" "3" "]" âŸ© âŸ¨ "[" "2" "]" "5" "[" "4" âŸ© âŸ¨ "[" âŸ© âŸ©
#
# Splitting is standard:
#
#     { 1â†“1âŠ¸â†“Â¨(+`"["âŠ¸â‰¡Â¨ğ•©)âŠ”ğ•© } "["â€¿"3"â€¿"4"â€¿"]"â€¿"["â€¿"9"â€¿"10"
# âŸ¨ âŸ¨ "3" "4" "]" âŸ© âŸ¨ "9" "10" âŸ© âŸ©
#
# And Replace should be self-explanatory as well. When folding, we split the
# accumulator on the first opening bracket, and then plug whatever we find
# into the closing bracket of the given element.
#
#     {(Split ğ•©) Replace ğ•¨}Â´ dâŠ”t
# â”Œâ”€
# Â· â”Œâ”€
# Â· "1" â”Œâ”€                             "6"
#      Â· âŸ¨ "2" âŸ¨âŸ© "5" âŸ© "3" âŸ¨ "4" âŸ©
#                                   â”˜
#                                         â”˜
#                                           â”˜
#
# The rest is just boilerplate so that a nicely formatted list falls out.

### Flat array approach

FATok â† {
  ns â† Â»âŠ¸< nâ†ğ•©âˆŠ'0'+â†•10
  ds â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`ns)âŠ”ğ•©  # All digits
  f  â† nsâˆ¨ğ•©âˆŠ"[]"                  # First occurrences
  âŸ¨ 'Â·'Â¨âŒ¾((f/n)âŠ¸/)(f/ğ•©), ds âŸ©
}

#     a â† "[1,2,[3,4,[5,6]],7,8,[9,10]]"
# "[1,2,[3,4,[5,6]],7,8,[9,10]]"
#     ns â† Â»âŠ¸< nâ†aâˆŠ'0'+â†•10        # ns is the first occurrence of a number (so "10" gets 1â€¿0)
# âŸ¨ 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 1 0 0 0 âŸ©
#     n                           # n is all numbers (so "10" gets 1â€¿1)
# âŸ¨ 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 1 1 0 0 âŸ©
#     ds â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`ns)âŠ”a # Number tokens in a separate list
# âŸ¨ 1 2 3 4 5 6 7 8 9 10 âŸ©
#     f  â† nsâˆ¨aâˆŠ"[]"                 # First occurrences of everything
# âŸ¨ 1 1 0 1 0 1 1 0 1 0 1 1 0 1 1 1 0 1 0 1 0 1 1 0 1 0 1 1 âŸ©
#
# At this point we need to work with the shape of the array we are trying to
# build -- that in which everything is represented by one character only.
#
#     f/a                 # Shape of the new array
# "[12[34[56]]78[91]]"
#     f/n                 # What are the number tokens in the new array?
# âŸ¨ 0 1 1 0 1 1 0 1 1 0 0 1 1 0 1 1 0 0 âŸ©
#     'Â·'Â¨âŒ¾((f/n)âŠ¸/)(f/a) # Replace numbers with 'Â·'
# "[Â·Â·[Â·Â·[Â·Â·]]Â·Â·[Â·Â·]]"

FAParse â† {
  tokâ€¿num â† FATok ğ•©
  o â† '['=tok
  c â† ']'=tok
  g â† â‹+`(o-c)          # Grading by depth
  f â† tokâˆŠ"Â·]"          # Numbers and nesting
  k â† â‹â‹ (f/'Â·'=tok) + 2Ã—f/c
  l â† (â‹g)âŠ +`'['=gâŠtok # Sublist index
  i â† k âŠ (â†•nv) âˆ¾ (nvâ†â‰ num)+ â‰ âŠ¸- c/Â»l
  val â† num             # Mutation is evil
  {valâˆ¾â†©<ğ•©âŠvalâ‹„@}Â¨ âŒ½((+Â´c)âˆ¾Ëœ1-Ëœf/l)âŠ”i
  Â¯1âŠ‘val
}

### Performance

# Some AoC day using exactly this format.
SplitF â‡ { ((Â¯1+âŠ¢Ã—Â·+`Â»âŠ¸<)Â¬ğ•¨âŠ¸â‰¡Â¨ğ•©)âŠ”ğ•© }
input â† ']'âˆ¾Ëœ '['âˆ¾ Â¯1â†“ âˆ¾ âˆ¾âŸœ","Â¨ âˆ¾âŸ¨âŸ©SplitF â€¢FLines"/home/slot/repos/advent/aoc2022/inputs/day13.txt"

(RDParse input) â‰¡ AParse input  # â‡’ 1
(FAParse input) â‰¡ AParse input  # â‡’ 1
100 RDParseâ€¢_timed input        # â‡’ 0.00269128438
100 AParse â€¢_timed input        # â‡’ 0.00236296291
100 FAParseâ€¢_timed input        # â‡’ 0.00118868171
