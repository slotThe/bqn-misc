# Parsing a subset of JSON. The rules are:
#
# + Only integers.
# + Only ASCII in strings.
# + No constants.
# + Currently there is no input validation -- it better be valid!
#

# 'Lex json' yields 'tokensâ€¿numbersâ€¿strings', where 'tokens' is a string of
# characters each representing a token -- with '"' for strings and '0' for
# numbers --, 'numbers' is a list of numbers in order of occurrence, and
# 'strings' is a list of strings in order of occurrence.
#
#     Lex "{""a"": 123, ""bcde"": [1,42,30]}"
# âŸ¨ "{"":0,"":[0,0,0]}" âŸ¨ 123 1 42 30 âŸ© âŸ¨ "a" "bcde" âŸ© âŸ©
Lex â† {
  x â† (Â¬âˆŠ)âŸœ(@+10â€¿13â€¿32)âŠ¸/ğ•© # Remove whitespace
  # Numbers
  nb â† Â»âŠ¸< nâ†xâˆŠ'0'+â†•10     # Number beginnings
  numbers â† â€¢ParsefloatÂ¨ xâŠ”Ëœ 1-ËœnÃ—+`nb
  # Strings
  sb â† Â»âŠ¸< sâ†â‰ `'"'=x       # String beginnings
  strings â† xâŠ”Ëœ 1-Ëœ(s>sb)Ã—+`sb
  # Tokenise
  ts â† nbâˆ¨sbâˆ¨xâˆŠ"{}[],:"    # Tokens
  âŸ¨ '0'Â¨âŒ¾((ts/nb)âŠ¸/) ts/x
    numbers
    strings
  âŸ©
}

# XXX: WIP. Only parses purely numeric lists right now.
Parse â† {
  tsâ€¿nsâ€¿ss â† Lex ğ•©
  oâ†ts='[' â‹„ câ†ts=']' â‹„ dâ†â‹+`(o-c)
  n â† tsâˆŠ"0]"                           # Numbers and nesting
  vi â† â‹â‹ (n/ts='0') + 2Ã—n/c            # Value indices
  l â† (â‹d)âŠ+`'['=dâŠts
  i â† viâŠ(â†•â‰ ns)âˆ¾(â‰ ns)+ â‰ âŠ¸- c/Â»l
  vs â† ns
  {vs âˆ¾â†© <ğ•©âŠvs â‹„@}Â¨ âŒ½iâŠ”Ëœ(+Â´c)âˆ¾Ëœ1-Ëœn/l
  Â¯1âŠ‘vs
}

### Tests

#### Lexing

âŸ¨"{"":0,"":[0,0,0]}", 123â€¿1â€¿42â€¿30, "a"â€¿"bcde"âŸ©â‰¡ Lex "{""a"": 123, ""bcde"": [1,42,30]}"

#### Parsing

âŸ¨âŸ©â‰¡ Parse "[ ]"
âŸ¨1,2,3âŸ©â‰¡ Parse " [ 1 , 2 , 3 ] "
âŸ¨1,âŸ¨42,âŸ¨âŸ¨0âŸ©,2,3âŸ©âŸ©,30âŸ©â‰¡ Parse "[1, [42, [[0 ], 2, 3]], 30]"
âŸ¨1,2,âŸ¨âŸ©,âŸ¨3,4,âŸ¨5,6âŸ©âŸ©,7,8,âŸ¨9,âŸ¨âŸ©,10âŸ©âŸ©â‰¡ Parse "[1,2,[ ],[3,4,[5,6]],7,8,[9,[],10]]"
